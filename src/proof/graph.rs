//! The graph-based prover

use super::expr::Expr;
use super::{ProofResult, Requirement, Term};
use crate::ast::Ident;
use std::marker::PhantomData;

#[derive(Clone, Debug)]
pub struct Prover {
    /// The set of expression nodes in the graph, each represented by a sum of terms and edges to
    /// the values they are less than.
    nodes: Vec<Node>,
}

#[derive(Copy, Clone, Debug)]
struct NodeId(usize);

#[derive(Clone, Debug)]
struct Node {
    expr: Vec<Term>,
    // expr <= [NodeId].expr + edge
    less_than: Vec<(Edge, NodeId)>,
}

#[derive(Copy, Clone, Debug)]
struct Edge(i128);

impl Prover {
    /// An identical function to `super::Prover::prove`, except this is a helper for the recursion,
    /// which we use to manage attempting to prove the contrapositive.
    fn prove(&self, req: &Requirement, recurse: bool) -> ProofResult {
        // Attempts to prove the requirement by finding the path the shortest length from req.lhs
        // to req.rhs
        //
        // This is equivalent to finding the smallest value of C where lhs <= rhs + C still holds.
        // Only if C <= req.constant can we infer that the requirement is satisfied
        // (i.e. lhs <= rhs + constant).
        //
        // Of course, both the left- and right-hand side expressions need to be present in the
        // graph; if they aren't, we'll return that the statement is undetermined.

        // find the starting and ending points of the path through the graph
        let start_node_idx = match self.nodes.iter().position(|n| n.expr == req.lhs) {
            Some(i) => i,
            None => return ProofResult::Undetermined,
        };

        let end_node_idx = match self.nodes.iter().position(|n| n.expr == req.rhs) {
            Some(i) => i,
            None => return ProofResult::Undetermined,
        };

        // We're going to perform the Bellman-Ford algorithm to compute the shortest path between
        // start_node and end_node.
        //
        // This is largely replicated from the excellent wikipedia pseudocode for the algorithm,
        // available here: https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm#Algorithm

        // initialize distances. We don't track predecesssors here because we don't actually care
        // about the path itself, just the distance
        let mut distances = vec![i128::MAX; self.nodes.len()];
        distances[start_node_idx] = 0_i128;

        for _loop_iter in 0..self.nodes.len() {
            let mut changed = false;

            for (u, node) in self.nodes.iter().enumerate() {
                for &(Edge(weight), NodeId(v)) in node.less_than.iter() {
                    if distances[u] + weight < distances[v] {
                        changed = true;
                        distances[v] = distances[u] + weight;
                    }
                }
            }

            // We don't actually check for negative-weight cycles right now, because that's a
            // contradiction, and (1) contradictions can imply anything, and (2) that will probably
            // be checked at creation later.
            // if loop_iter == self.nodes.len() - 1 && changed {
            //    // negative-weight cycle
            // }

            if !changed {
                break;
            }
        }

        if distances[end_node_idx] <= req.constant {
            return ProofResult::True;
        } else if !recurse {
            return ProofResult::Undetermined;
        }

        // Otherwise, we'll check to see if we can prove that it's false by inverting the
        // requirement

        let contra_req = Requirement {
            // swap the sides
            lhs: req.rhs.clone(),
            rhs: req.lhs.clone(),
            // reverse the constant and subtract one. This is because:
            //   x > y + C  =>  x ≥ y + C+1  =>  -x ≤ -y - C-1
            // given that we are operating only on integers
            constant: (-req.constant) - 1,
            _marker: PhantomData,
        };

        let contra_res = self.prove(&contra_req, false);
        match contra_res {
            ProofResult::True => ProofResult::False,
            ProofResult::Undetermined => ProofResult::Undetermined,
            // We never get a false proof statement from recursing because we tell *it* not to
            // recurse - `False` can only be generated by recursion
            ProofResult::False => panic!("unexpected false result from proof recursion"),
        }
    }
}

impl<'a> super::Prover<'a> for Prover {
    fn new(reqs: Vec<Requirement<'a>>) -> Self {
        let mut nodes: Vec<Node> = Vec::new();
        for req in reqs {
            let lhs_idx = match nodes.iter().position(|n| n.expr == req.lhs) {
                Some(i) => i,
                None => {
                    nodes.push(Node {
                        expr: req.lhs.clone(),
                        less_than: Vec::new(),
                    });
                    nodes.len() - 1
                }
            };

            let rhs_idx = match nodes.iter().position(|n| n.expr == req.rhs) {
                Some(i) => i,
                None => {
                    nodes.push(Node {
                        expr: req.rhs.clone(),
                        less_than: Vec::new(),
                    });
                    nodes.len() - 1
                }
            };

            nodes[lhs_idx]
                .less_than
                .push((Edge(req.constant), NodeId(rhs_idx)));
        }

        Prover { nodes }
    }

    fn prove(&self, req: &Requirement) -> ProofResult {
        self.prove(req, true)
    }

    fn define(&'a self, x: Ident<'a>, expr: &'a Expr<'a>) -> Self {
        todo!()
    }

    fn shadow(&self, x: Ident<'a>) -> Self {
        todo!()
    }
}
